import unsafe
import libc

const TYPE_NULL = 1
const TYPE_BOOL = 2
const TYPE_I8 = 3
const TYPE_U8 = 4
const TYPE_I16 = 5
const TYPE_U16 = 6
const TYPE_I32 = 7
const TYPE_U32 = 8
const TYPE_I64 = 9
const TYPE_U64 = 10
const TYPE_INT = 9 // trans i64 in compiler time
const TYPE_UINT = 10 // trans u64 in compiler time

const TYPE_F32 = 11
const TYPE_F64 = 12
const TYPE_FLOAT = 12 // trans f64 in compiler time

const TYPE_STRING = 13
const TYPE_VEC = 14
const TYPE_ARR = 15
const TYPE_MAP = 16
const TYPE_SET = 17
const TYPE_TUP = 18
const TYPE_STRUCT = 19
const TYPE_FN = 20
const TYPE_CHAN = 21
const TYPE_COROUTINE_T = 22

const TYPE_PTR = 23
const TYPE_RAWPTR = 24
const TYPE_ANYPTR = 25

const TYPE_UNION = 26

type type_field_t = struct{
    string name
    int hash
    int offset
}

type type_t = struct{
    int size
    int hash
    int kind
    u8 align
    [int] hashes
    [type_field_t] fields // type struct exclusive
}

type rtype_struct_t = struct{
    i64 name_offset
    i64 hash
    i64 offset
}

type rtype_t = struct{
    u64 ident_offset
    u64 size
    u8 in_heap

    i64 hash
    u64 last_ptr
    u32 kind // type_kind
    i64 malloc_gc_bits_offset
    u64 gc_bits
    u8 align
    u16 length
    i64 hashes_offset
}

#linkid rt_find_rtype
fn find_rtype(int hash):rawptr<rtype_t>

#linkid rt_find_data
fn find_data(int offset):anyptr

#linkid rt_find_strtable
fn find_strtable(int offset):libc.cstr

fn typeof_hash(i64 hash):type_t! {
    if hash <= 0 {
        throw errorf('hash must be greater than 0')
    }
    var r = find_rtype(hash)

    var t = type_t{
        size = r.size as int,
        hash = r.hash,
        kind = r.kind as int,
        align = r.align,
        hashes = vec_new<int>(0, 0),
        fields = vec_new<type_field_t>(type_field_t{}, 0),
    }

    if r.kind == TYPE_STRUCT {
        t.fields = vec_new<type_field_t>(type_field_t{}, r.length as int)
        var temp_fields = unsafe.vec_new(find_data(r.hashes_offset) as rawptr<rtype_struct_t>, r.length as int)

        for i,field in temp_fields {
            t.fields[i] = type_field_t{
                name = find_strtable(field.name_offset).to_string(),
                hash = field.hash,
                offset = field.offset,
            }
        }
    } else {
        if r.length > 0 {
            t.hashes = vec_new<int>(0, r.length as int)

            var temp_hashes = unsafe.vec_new(find_data(r.hashes_offset) as rawptr<i64>, r.length as int)
            var len = t.hashes.copy(temp_hashes)
            assert(len == t.hashes.len())
        }
    }

    return t
}

fn typeof<T>(T t):type_t! {
    var hash = @reflect_hash(T)
    return typeof_hash(hash)
}